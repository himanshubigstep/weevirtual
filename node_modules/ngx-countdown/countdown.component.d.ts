import { OnChanges, SimpleChanges, OnDestroy, EventEmitter, OnInit, SimpleChange, ChangeDetectorRef, TemplateRef, NgZone } from '@angular/core';
import { CountdownConfig, CountdownEvent, CountdownItem } from './interfaces';
import { CountdownTimer } from './countdown.timer';
import { CountdownGlobalConfig } from './countdown.config';
import * as ɵngcc0 from '@angular/core';
export declare class CountdownComponent implements OnInit, OnChanges, OnDestroy {
    private locale;
    private timer;
    private defCog;
    private cdr;
    private ngZone;
    private frequency;
    private _notify;
    private status;
    private isDestroy;
    i: CountdownItem;
    left: number;
    config: CountdownConfig;
    render: TemplateRef<void>;
    readonly event: EventEmitter<CountdownEvent>;
    constructor(locale: string, timer: CountdownTimer, defCog: CountdownGlobalConfig, cdr: ChangeDetectorRef, ngZone: NgZone);
    /**
     * Start countdown, you must manually call when `demand: false`
     */
    begin(): void;
    /**
     * Restart countdown
     */
    restart(): void;
    /**
     * Stop countdown, must call `restart` when stopped, it's different from pause, unable to recover
     */
    stop(): void;
    /**
     * Pause countdown, you can use `resume` to recover again
     */
    pause(): void;
    /**
     * Resume countdown
     */
    resume(): void;
    private callEvent;
    private init;
    private destroy;
    /**
     * 更新时钟
     */
    private reflow;
    /**
     * 获取倒计时剩余帧数
     */
    private getLeft;
    ngOnInit(): void;
    ngOnDestroy(): void;
    ngOnChanges(changes: {
        [P in keyof this]?: SimpleChange;
    } & SimpleChanges): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<CountdownComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<CountdownComponent, "countdown", never, { "config": "config"; "render": "render"; }, { "event": "event"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY291bnRkb3duLmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJjb3VudGRvd24uY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzLCBPbkRlc3Ryb3ksIEV2ZW50RW1pdHRlciwgT25Jbml0LCBTaW1wbGVDaGFuZ2UsIENoYW5nZURldGVjdG9yUmVmLCBUZW1wbGF0ZVJlZiwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb3VudGRvd25Db25maWcsIENvdW50ZG93bkV2ZW50LCBDb3VudGRvd25JdGVtIH0gZnJvbSAnLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IENvdW50ZG93blRpbWVyIH0gZnJvbSAnLi9jb3VudGRvd24udGltZXInO1xuaW1wb3J0IHsgQ291bnRkb3duR2xvYmFsQ29uZmlnIH0gZnJvbSAnLi9jb3VudGRvd24uY29uZmlnJztcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIENvdW50ZG93bkNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgbG9jYWxlO1xuICAgIHByaXZhdGUgdGltZXI7XG4gICAgcHJpdmF0ZSBkZWZDb2c7XG4gICAgcHJpdmF0ZSBjZHI7XG4gICAgcHJpdmF0ZSBuZ1pvbmU7XG4gICAgcHJpdmF0ZSBmcmVxdWVuY3k7XG4gICAgcHJpdmF0ZSBfbm90aWZ5O1xuICAgIHByaXZhdGUgc3RhdHVzO1xuICAgIHByaXZhdGUgaXNEZXN0cm95O1xuICAgIGk6IENvdW50ZG93bkl0ZW07XG4gICAgbGVmdDogbnVtYmVyO1xuICAgIGNvbmZpZzogQ291bnRkb3duQ29uZmlnO1xuICAgIHJlbmRlcjogVGVtcGxhdGVSZWY8dm9pZD47XG4gICAgcmVhZG9ubHkgZXZlbnQ6IEV2ZW50RW1pdHRlcjxDb3VudGRvd25FdmVudD47XG4gICAgY29uc3RydWN0b3IobG9jYWxlOiBzdHJpbmcsIHRpbWVyOiBDb3VudGRvd25UaW1lciwgZGVmQ29nOiBDb3VudGRvd25HbG9iYWxDb25maWcsIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsIG5nWm9uZTogTmdab25lKTtcbiAgICAvKipcbiAgICAgKiBTdGFydCBjb3VudGRvd24sIHlvdSBtdXN0IG1hbnVhbGx5IGNhbGwgd2hlbiBgZGVtYW5kOiBmYWxzZWBcbiAgICAgKi9cbiAgICBiZWdpbigpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJlc3RhcnQgY291bnRkb3duXG4gICAgICovXG4gICAgcmVzdGFydCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFN0b3AgY291bnRkb3duLCBtdXN0IGNhbGwgYHJlc3RhcnRgIHdoZW4gc3RvcHBlZCwgaXQncyBkaWZmZXJlbnQgZnJvbSBwYXVzZSwgdW5hYmxlIHRvIHJlY292ZXJcbiAgICAgKi9cbiAgICBzdG9wKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogUGF1c2UgY291bnRkb3duLCB5b3UgY2FuIHVzZSBgcmVzdW1lYCB0byByZWNvdmVyIGFnYWluXG4gICAgICovXG4gICAgcGF1c2UoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBSZXN1bWUgY291bnRkb3duXG4gICAgICovXG4gICAgcmVzdW1lKCk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBjYWxsRXZlbnQ7XG4gICAgcHJpdmF0ZSBpbml0O1xuICAgIHByaXZhdGUgZGVzdHJveTtcbiAgICAvKipcbiAgICAgKiDmm7TmlrDml7bpkp9cbiAgICAgKi9cbiAgICBwcml2YXRlIHJlZmxvdztcbiAgICAvKipcbiAgICAgKiDojrflj5blgJLorqHml7bliankvZnluKfmlbBcbiAgICAgKi9cbiAgICBwcml2YXRlIGdldExlZnQ7XG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IHtcbiAgICAgICAgW1AgaW4ga2V5b2YgdGhpc10/OiBTaW1wbGVDaGFuZ2U7XG4gICAgfSAmIFNpbXBsZUNoYW5nZXMpOiB2b2lkO1xufVxuIl19